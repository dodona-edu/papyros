!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.Papyros=n():e.Papyros=n()}(self,(()=>(()=>{"use strict";var __webpack_modules__={"./node_modules/file-loader/dist/cjs.js!./src/workers/python/python_package.tar.gz.load_by_url":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "f130e162ac4dca1579792cc10325776b.load_by_url");\n\n//# sourceURL=webpack://Papyros/./src/workers/python/python_package.tar.gz.load_by_url?./node_modules/file-loader/dist/cjs.js')},"./src/Backend.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Backend: () => (/* binding */ Backend),\n/* harmony export */   RunMode: () => (/* binding */ RunMode)\n/* harmony export */ });\n/* harmony import */ var _BackendEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BackendEvent */ "./src/BackendEvent.ts");\n/* harmony import */ var comsync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! comsync */ "./node_modules/comsync/dist/index.js");\n/* harmony import */ var comsync__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(comsync__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _BackendEventQueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BackendEventQueue */ "./src/BackendEventQueue.ts");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nvar RunMode;\n(function (RunMode) {\n    RunMode["Run"] = "run";\n    RunMode["Debug"] = "debug";\n    RunMode["Doctest"] = "doctest";\n})(RunMode || (RunMode = {}));\nclass Backend {\n    /**\n     * Constructor is limited as it is meant to be used as a WebWorker\n     * Proper initialization occurs in the launch method when the worker is started\n     * Synchronously exposing methods should be done here\n     */\n    constructor() {\n        this.extras = {};\n        this.onEvent = () => {\n            // Empty, initialized in launch\n        };\n        this.runCode = this.syncExpose()(this.runCode.bind(this));\n        this.queue = {};\n    }\n    /**\n     * @return {any} The function to expose methods for Comsync to allow interrupting\n     */\n    syncExpose() {\n        return comsync__WEBPACK_IMPORTED_MODULE_2__.syncExpose;\n    }\n    /**\n     * Initialize the backend by doing all setup-related work\n     * @param {function(BackendEvent):void} onEvent Callback for when events occur\n     * @param {function():void} onOverflow Callback for when overflow occurs\n     * @return {Promise<void>} Promise of launching\n     */\n    launch(onEvent, onOverflow) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.onEvent = (e) => {\n                onEvent(e);\n                if (e.type === _BackendEvent__WEBPACK_IMPORTED_MODULE_0__.BackendEventType.Sleep) {\n                    return this.extras.syncSleep(e.data);\n                }\n                else if (e.type === _BackendEvent__WEBPACK_IMPORTED_MODULE_0__.BackendEventType.Input) {\n                    return this.extras.readMessage();\n                }\n            };\n            this.queue = new _BackendEventQueue__WEBPACK_IMPORTED_MODULE_1__.BackendEventQueue(this.onEvent.bind(this), onOverflow);\n            return Promise.resolve();\n        });\n    }\n    /**\n     * Determine whether the modes supported by this Backend are active\n     * @param {string} code The current code in the editor\n     * @return {Array<RunMode>} The run modes of this Backend\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runModes(code) {\n        return [];\n    }\n    /**\n     * @return {boolean} Whether too many output events were generated\n     */\n    hasOverflow() {\n        return this.queue.hasOverflow();\n    }\n    /**\n     * @return {Array<BackendEvent>} The events that happened after overflow\n     */\n    getOverflow() {\n        return this.queue.getOverflow();\n    }\n    /**\n     * Provide files to be used by the backend\n     * @param {Record<string, string>} inlineFiles Map of file names to their contents\n     * @param {Record<string, string>} hrefFiles Map of file names to URLS with their contents\n     * @return {Promise<void>} Resolves when the files are present in the backend\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    provideFiles(inlineFiles, hrefFiles) {\n        return Promise.resolve();\n    }\n}\n\n\n//# sourceURL=webpack://Papyros/./src/Backend.ts?')},"./src/BackendEvent.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackendEventType: () => (/* binding */ BackendEventType)\n/* harmony export */ });\n/**\n * Enum representing all possible types for supported events\n */\nvar BackendEventType;\n(function (BackendEventType) {\n    BackendEventType["Start"] = "start";\n    BackendEventType["End"] = "end";\n    BackendEventType["Input"] = "input";\n    BackendEventType["Output"] = "output";\n    BackendEventType["Sleep"] = "sleep";\n    BackendEventType["Error"] = "error";\n    BackendEventType["Interrupt"] = "interrupt";\n    BackendEventType["Loading"] = "loading";\n    BackendEventType["Frame"] = "frame";\n    BackendEventType["FrameChange"] = "frame-change";\n    BackendEventType["Stop"] = "stop";\n})(BackendEventType || (BackendEventType = {}));\n\n\n//# sourceURL=webpack://Papyros/./src/BackendEvent.ts?')},"./src/BackendEventQueue.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackendEventQueue: () => (/* binding */ BackendEventQueue)\n/* harmony export */ });\n/* harmony import */ var _BackendEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BackendEvent */ "./src/BackendEvent.ts");\n\n/**\n * Queue to limit the amount of messages sent between threads\n * This prevents communication issues which arise either in Comlink\n * or in the WebWorker message passing code\n */\nclass BackendEventQueue {\n    /**\n     * @param {function(BackendEvent):void} callback Function to process events in the queue\n     * @param {function():void} onOverflow Callback for when overflow occurs\n     * @param {number} limit The maximal amount of output lines to send before overflowing\n     * @param {number} flushTime The time in milliseconds before sending events through\n     */\n    constructor(callback, onOverflow, limit = 1000, flushTime = 100) {\n        this.callback = callback;\n        this.limit = limit;\n        this.flushTime = flushTime;\n        this.queue = [];\n        this.overflow = [];\n        this.onOverflow = onOverflow;\n        this.overflown = false;\n        this.lastFlushTime = new Date().getTime();\n        this.sendCount = 0;\n        this.decoder = new TextDecoder();\n    }\n    /**\n     * Add an element to the queue\n     * @param {BackendEventType} type The type of the event\n     * @param {string | BufferSource} text The data for the event\n     * @param {string | any} extra Extra data for the event\n     * If string, interpreted as the contentType\n     * If anything else, it should contain a contentType\n     * If the contentType is not textual, an error is thrown\n     */\n    put(type, text, extra) {\n        let stringData = "";\n        if (typeof text !== "string") {\n            stringData = this.decoder.decode(text);\n        }\n        else {\n            stringData = text;\n        }\n        let extraArgs = {};\n        let contentType = "text/plain";\n        if (extra) {\n            if (typeof extra === "string") {\n                contentType = extra;\n            }\n            else {\n                contentType = extra["contentType"];\n                delete extra["contentType"];\n                extraArgs = extra;\n            }\n        }\n        if (this.queue.length === 0 ||\n            !contentType.startsWith("text") || // Non textual cannot be combined\n            this.queue[this.queue.length - 1].type !== type || // Different type\n            // Can\'t be combined if contentType doesn\'t match\n            this.queue[this.queue.length - 1].contentType !== contentType) {\n            this.queue.push(Object.assign({ type: type, data: stringData, contentType: contentType }, extraArgs));\n        }\n        else { // Same kind of event, combine into one\n            this.queue[this.queue.length - 1].data += stringData;\n        }\n        if (this.shouldFlush()) {\n            this.flush();\n        }\n    }\n    /**\n     * @return {boolean} Whether the queue contents should be flushed\n     */\n    shouldFlush() {\n        return this.queue.length > 1 || // different types of Events present\n            new Date().getTime() - this.lastFlushTime > this.flushTime;\n    }\n    /**\n     * Reset the queue contents for a new run\n     */\n    reset() {\n        this.queue = [];\n        this.overflow = [];\n        this.overflown = false;\n        this.lastFlushTime = new Date().getTime();\n        this.sendCount = 0;\n    }\n    /**\n     * @param {BackendEvent} e The event put in the queue\n     * @return {number} The amount of lines of data in the event\n     */\n    static lines(e) {\n        return (e.data.match(/\\n/g) || []).length + 1;\n    }\n    /**\n     * Flush the queue contents using the callback\n     */\n    flush() {\n        this.queue.forEach(e => {\n            if (e.type === _BackendEvent__WEBPACK_IMPORTED_MODULE_0__.BackendEventType.Output) {\n                this.overflow.push(e);\n                if (this.sendCount < this.limit) {\n                    this.sendCount += BackendEventQueue.lines(e);\n                    this.callback(e);\n                }\n                else if (!this.overflown) {\n                    this.overflown = true;\n                    this.onOverflow();\n                }\n            }\n            else {\n                this.callback(e);\n            }\n        });\n        this.queue = [];\n        this.lastFlushTime = new Date().getTime();\n    }\n    /**\n     * @return {boolean} Whether too many output events were generated\n     */\n    hasOverflow() {\n        return this.overflown;\n    }\n    /**\n     * @return {Array<BackendEvent>} The events that happened after overflow\n     */\n    getOverflow() {\n        return this.overflow;\n    }\n    /**\n     * @param {Function} callback The event-consuming callback\n     */\n    setCallback(callback) {\n        this.callback = callback;\n    }\n}\n\n\n//# sourceURL=webpack://Papyros/./src/BackendEventQueue.ts?')},"./src/workers/python/PythonWorker.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PythonWorker: () => (/* binding */ PythonWorker)\n/* harmony export */ });\n/* harmony import */ var _Backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Backend */ "./src/Backend.ts");\n/* harmony import */ var pyodide_worker_runner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pyodide-worker-runner */ "./node_modules/pyodide-worker-runner/dist/index.js");\n/* harmony import */ var pyodide_worker_runner__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pyodide_worker_runner__WEBPACK_IMPORTED_MODULE_1__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n/* eslint-disable-next-line */\nconst pythonPackageUrl = (__webpack_require__(/*! !!file-loader!./python_package.tar.gz.load_by_url */ "./node_modules/file-loader/dist/cjs.js!./src/workers/python/python_package.tar.gz.load_by_url")["default"]);\n/**\n * Implementation of a Python backend for Papyros\n * Powered by Pyodide (https://pyodide.org/)\n */\nclass PythonWorker extends _Backend__WEBPACK_IMPORTED_MODULE_0__.Backend {\n    constructor() {\n        super();\n        this.pyodide = {};\n        this.papyros = {};\n        this.installPromise = null;\n    }\n    static convert(data) {\n        return data.toJs ? data.toJs({ dict_converter: Object.fromEntries }) : data;\n    }\n    /**\n     * @return {any} Function to expose a method with Pyodide support\n     */\n    syncExpose() {\n        return pyodide_worker_runner__WEBPACK_IMPORTED_MODULE_1__.pyodideExpose;\n    }\n    static getPyodide() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield (0,pyodide_worker_runner__WEBPACK_IMPORTED_MODULE_1__.loadPyodideAndPackage)({ url: pythonPackageUrl, format: ".tgz" });\n        });\n    }\n    launch(onEvent, onOverflow) {\n        const _super = Object.create(null, {\n            launch: { get: () => super.launch }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.launch.call(this, onEvent, onOverflow);\n            this.pyodide = yield PythonWorker.getPyodide();\n            // Python calls our function with a PyProxy dict or a Js Map,\n            // These must be converted to a PapyrosEvent (JS Object) to allow message passing\n            this.papyros = this.pyodide.pyimport("papyros").Papyros.callKwargs({\n                callback: (e) => {\n                    const converted = PythonWorker.convert(e);\n                    return this.onEvent(converted);\n                },\n                buffer_constructor: (cb) => {\n                    this.queue.setCallback(cb);\n                    return this.queue;\n                }\n            });\n            // preload micropip to allow installing packages\n            yield this.pyodide.loadPackage("micropip");\n        });\n    }\n    /**\n     * Helper method to install imports and prevent race conditions with double downloading\n     * @param {string} code The code containing import statements\n     */\n    installImports(code) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.installPromise == null) {\n                this.installPromise = this.papyros.install_imports.callKwargs({\n                    source_code: code,\n                    ignore_missing: true\n                });\n            }\n            yield this.installPromise;\n            this.installPromise = null;\n        });\n    }\n    runModes(code) {\n        let modes = super.runModes(code);\n        if (this.papyros.has_doctests(code)) {\n            modes = [_Backend__WEBPACK_IMPORTED_MODULE_0__.RunMode.Doctest, ...modes];\n        }\n        modes = [_Backend__WEBPACK_IMPORTED_MODULE_0__.RunMode.Debug, ...modes];\n        return modes;\n    }\n    runCode(extras_1, code_1) {\n        return __awaiter(this, arguments, void 0, function* (extras, code, mode = "exec") {\n            this.extras = extras;\n            if (extras.interruptBuffer) {\n                this.pyodide.setInterruptBuffer(extras.interruptBuffer);\n            }\n            yield this.installImports(code);\n            return yield this.papyros.run_async.callKwargs({\n                source_code: code,\n                mode: mode\n            });\n        });\n    }\n    lintCode(code) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.installImports(code);\n            return PythonWorker.convert(this.papyros.lint(code));\n        });\n    }\n    provideFiles(inlineFiles, hrefFiles) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.papyros.provide_files.callKwargs({\n                inline_files: JSON.stringify(inlineFiles),\n                href_files: JSON.stringify(hrefFiles)\n            });\n        });\n    }\n}\n\n\n//# sourceURL=webpack://Papyros/./src/workers/python/PythonWorker.ts?')},"./src/workers/python/worker.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");\n/* harmony import */ var _PythonWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PythonWorker */ "./src/workers/python/PythonWorker.ts");\n\n\nconst worker = new _PythonWorker__WEBPACK_IMPORTED_MODULE_0__.PythonWorker();\ncomlink__WEBPACK_IMPORTED_MODULE_1__.expose(worker);\n\n\n//# sourceURL=webpack://Papyros/./src/workers/python/worker.ts?')}},__webpack_module_cache__={},deferred,leafPrototypes,getProto,next;function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(r.exports,r,r.exports,__webpack_require__),r.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.x=()=>{var e=__webpack_require__.O(void 0,["vendors-node_modules_comsync_dist_index_js","vendors-node_modules_pyodide-worker-runner_dist_index_js"],(()=>__webpack_require__("./src/workers/python/worker.ts")));return e=__webpack_require__.O(e)},deferred=[],__webpack_require__.O=(e,n,r,t)=>{if(!n){var _=1/0;for(i=0;i<deferred.length;i++){for(var[n,r,t]=deferred[i],o=!0,a=0;a<n.length;a++)(!1&t||_>=t)&&Object.keys(__webpack_require__.O).every((e=>__webpack_require__.O[e](n[a])))?n.splice(a--,1):(o=!1,t<_&&(_=t));if(o){deferred.splice(i--,1);var s=r();void 0!==s&&(e=s)}}return e}t=t||0;for(var i=deferred.length;i>0&&deferred[i-1][2]>t;i--)deferred[i]=deferred[i-1];deferred[i]=[n,r,t]},__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},getProto=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,__webpack_require__.t=function(e,n){if(1&n&&(e=this(e)),8&n)return e;if("object"==typeof e&&e){if(4&n&&e.__esModule)return e;if(16&n&&"function"==typeof e.then)return e}var r=Object.create(null);__webpack_require__.r(r);var t={};leafPrototypes=leafPrototypes||[null,getProto({}),getProto([]),getProto(getProto)];for(var _=2&n&&e;"object"==typeof _&&!~leafPrototypes.indexOf(_);_=getProto(_))Object.getOwnPropertyNames(_).forEach((n=>t[n]=()=>e[n]));return t.default=()=>e,__webpack_require__.d(r,t),r},__webpack_require__.d=(e,n)=>{for(var r in n)__webpack_require__.o(n,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},__webpack_require__.f={},__webpack_require__.e=e=>Promise.all(Object.keys(__webpack_require__.f).reduce(((n,r)=>(__webpack_require__.f[r](e,n),n)),[])),__webpack_require__.u=e=>e+".js",__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;__webpack_require__.g.importScripts&&(e=__webpack_require__.g.location+"");var n=__webpack_require__.g.document;if(!e&&n&&(n.currentScript&&"SCRIPT"===n.currentScript.tagName.toUpperCase()&&(e=n.currentScript.src),!e)){var r=n.getElementsByTagName("script");if(r.length)for(var t=r.length-1;t>-1&&(!e||!/^http(s?):/.test(e));)e=r[t--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=e})(),(()=>{var e={src_workers_python_worker_ts:1};__webpack_require__.f.i=(n,r)=>{e[n]||importScripts(__webpack_require__.p+__webpack_require__.u(n))};var n=self.webpackChunkPapyros=self.webpackChunkPapyros||[],r=n.push.bind(n);n.push=n=>{var[t,_,o]=n;for(var a in _)__webpack_require__.o(_,a)&&(__webpack_require__.m[a]=_[a]);for(o&&o(__webpack_require__);t.length;)e[t.pop()]=1;r(n)}})(),next=__webpack_require__.x,__webpack_require__.x=()=>Promise.all([__webpack_require__.e("vendors-node_modules_comsync_dist_index_js"),__webpack_require__.e("vendors-node_modules_pyodide-worker-runner_dist_index_js")]).then(next);var __webpack_exports__=__webpack_require__.x();return __webpack_exports__})()));