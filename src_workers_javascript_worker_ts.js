!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.Papyros=n():e.Papyros=n()}(self,(()=>(()=>{"use strict";var __webpack_modules__={"./src/Backend.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Backend: () => (/* binding */ Backend)\n/* harmony export */ });\n/* harmony import */ var _BackendEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BackendEvent */ "./src/BackendEvent.ts");\n/* harmony import */ var comsync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! comsync */ "./node_modules/comsync/dist/index.js");\n/* harmony import */ var comsync__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(comsync__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _BackendEventQueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BackendEventQueue */ "./src/BackendEventQueue.ts");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass Backend {\n    /**\n     * Constructor is limited as it is meant to be used as a WebWorker\n     * Proper initialization occurs in the launch method when the worker is started\n     * Synchronously exposing methods should be done here\n     */\n    constructor() {\n        this.extras = {};\n        this.onEvent = () => {\n            // Empty, initialized in launch\n        };\n        this.runCode = this.syncExpose()(this.runCode.bind(this));\n        this.queue = {};\n    }\n    /**\n     * @return {any} The function to expose methods for Comsync to allow interrupting\n     */\n    syncExpose() {\n        return comsync__WEBPACK_IMPORTED_MODULE_2__.syncExpose;\n    }\n    /**\n     * Initialize the backend by doing all setup-related work\n     * @param {function(BackendEvent):void} onEvent Callback for when events occur\n     * @param {function():void} onOverflow Callback for when overflow occurs\n     * @return {Promise<void>} Promise of launching\n     */\n    launch(onEvent, onOverflow) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.onEvent = (e) => {\n                onEvent(e);\n                if (e.type === _BackendEvent__WEBPACK_IMPORTED_MODULE_0__.BackendEventType.Sleep) {\n                    return this.extras.syncSleep(e.data);\n                }\n                else if (e.type === _BackendEvent__WEBPACK_IMPORTED_MODULE_0__.BackendEventType.Input) {\n                    return this.extras.readMessage();\n                }\n            };\n            this.queue = new _BackendEventQueue__WEBPACK_IMPORTED_MODULE_1__.BackendEventQueue(this.onEvent.bind(this), onOverflow);\n            return Promise.resolve();\n        });\n    }\n    /**\n     * Determine whether the modes supported by this Backend are active\n     * @param {string} code The current code in the editor\n     * @return {Array<RunMode>} The run modes of this Backend\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runModes(code) {\n        return [];\n    }\n    /**\n     * Converts the context to a cloneable object containing useful properties\n     * to generate autocompletion suggestions with\n     * Class instances are not passable to workers, so we extract the useful information\n     * @param {CompletionContext} context Current context to autocomplete for\n     * @param {RegExp} expr Expression to match the previous token with\n     * @return {WorkerAutocompleteContext} Completion context that can be passed as a message\n     */\n    static convertCompletionContext(context, expr = /\\w*(\\.)?/) {\n        const [lineNr, column] = context.state.selection.ranges.map(range => {\n            const line = context.state.doc.lineAt(range.head);\n            return [line.number, (range.head - line.from)];\n        })[0];\n        const beforeMatch = context.matchBefore(expr);\n        return {\n            explicit: context.explicit,\n            before: beforeMatch,\n            pos: context.pos,\n            column: column,\n            line: lineNr,\n            text: context.state.doc.toString()\n        };\n    }\n    /**\n     * @return {boolean} Whether too many output events were generated\n     */\n    hasOverflow() {\n        return this.queue.hasOverflow();\n    }\n    /**\n     * @return {Array<BackendEvent>} The events that happened after overflow\n     */\n    getOverflow() {\n        return this.queue.getOverflow();\n    }\n}\n\n\n//# sourceURL=webpack://Papyros/./src/Backend.ts?')},"./src/BackendEvent.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BACKEND_EVENT_TYPES: () => (/* binding */ BACKEND_EVENT_TYPES),\n/* harmony export */   BackendEventType: () => (/* binding */ BackendEventType)\n/* harmony export */ });\n/**\n * Enum representing all possible types for supported events\n */\nvar BackendEventType;\n(function (BackendEventType) {\n    BackendEventType["Start"] = "start";\n    BackendEventType["End"] = "end";\n    BackendEventType["Input"] = "input";\n    BackendEventType["Output"] = "output";\n    BackendEventType["Sleep"] = "sleep";\n    BackendEventType["Error"] = "error";\n    BackendEventType["Interrupt"] = "interrupt";\n    BackendEventType["Loading"] = "loading";\n})(BackendEventType || (BackendEventType = {}));\n/**\n * All possible types for ease of iteration\n */\nconst BACKEND_EVENT_TYPES = [\n    BackendEventType.Start, BackendEventType.End,\n    BackendEventType.Input, BackendEventType.Output,\n    BackendEventType.Sleep, BackendEventType.Error,\n    BackendEventType.Interrupt, BackendEventType.Loading\n];\n\n\n//# sourceURL=webpack://Papyros/./src/BackendEvent.ts?')},"./src/BackendEventQueue.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackendEventQueue: () => (/* binding */ BackendEventQueue)\n/* harmony export */ });\n/* harmony import */ var _BackendEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BackendEvent */ "./src/BackendEvent.ts");\n\n/**\n * Queue to limit the amount of messages sent between threads\n * This prevents communication issues which arise either in Comlink\n * or in the WebWorker message passing code\n */\nclass BackendEventQueue {\n    /**\n     * @param {function(BackendEvent):void} callback Function to process events in the queue\n     * @param {function():void} onOverflow Callback for when overflow occurs\n     * @param {number} limit The maximal amount of output lines to send before overflowing\n     * @param {number} flushTime The time in milliseconds before sending events through\n     */\n    constructor(callback, onOverflow, limit = 1000, flushTime = 100) {\n        this.callback = callback;\n        this.limit = limit;\n        this.flushTime = flushTime;\n        this.queue = [];\n        this.overflow = [];\n        this.onOverflow = onOverflow;\n        this.overflown = false;\n        this.lastFlushTime = new Date().getTime();\n        this.sendCount = 0;\n        this.decoder = new TextDecoder();\n    }\n    /**\n     * Add an element to the queue\n     * @param {BackendEventType} type The type of the event\n     * @param {string | BufferSource} text The data for the event\n     * @param {string | any} extra Extra data for the event\n     * If string, interpreted as the contentType\n     * If anything else, it should contain a contentType\n     * If the contentType is not textual, an error is thrown\n     */\n    put(type, text, extra) {\n        let stringData = "";\n        if (typeof text !== "string") {\n            stringData = this.decoder.decode(text);\n        }\n        else {\n            stringData = text;\n        }\n        let extraArgs = {};\n        let contentType = "text/plain";\n        if (extra) {\n            if (typeof extra === "string") {\n                contentType = extra;\n            }\n            else {\n                contentType = extra["contentType"];\n                delete extra["contentType"];\n                extraArgs = extra;\n            }\n        }\n        if (this.queue.length === 0 ||\n            !contentType.startsWith("text") || // Non textual cannot be combined\n            this.queue[this.queue.length - 1].type !== type || // Different type\n            // Can\'t be combined if contentType doesn\'t match\n            this.queue[this.queue.length - 1].contentType !== contentType) {\n            this.queue.push(Object.assign({ type: type, data: stringData, contentType: contentType }, extraArgs));\n        }\n        else { // Same kind of event, combine into one\n            this.queue[this.queue.length - 1].data += stringData;\n        }\n        if (this.shouldFlush()) {\n            this.flush();\n        }\n    }\n    /**\n     * @return {boolean} Whether the queue contents should be flushed\n     */\n    shouldFlush() {\n        return this.queue.length > 1 || // different types of Events present\n            new Date().getTime() - this.lastFlushTime > this.flushTime;\n    }\n    /**\n     * Reset the queue contents for a new run\n     */\n    reset() {\n        this.queue = [];\n        this.overflow = [];\n        this.overflown = false;\n        this.lastFlushTime = new Date().getTime();\n        this.sendCount = 0;\n    }\n    /**\n     * @param {BackendEvent} e The event put in the queue\n     * @return {number} The amount of lines of data in the event\n     */\n    static lines(e) {\n        return (e.data.match(/\\n/g) || []).length + 1;\n    }\n    /**\n     * Flush the queue contents using the callback\n     */\n    flush() {\n        this.queue.forEach(e => {\n            if (e.type === _BackendEvent__WEBPACK_IMPORTED_MODULE_0__.BackendEventType.Output) {\n                this.overflow.push(e);\n                if (this.sendCount < this.limit) {\n                    this.sendCount += BackendEventQueue.lines(e);\n                    this.callback(e);\n                }\n                else if (!this.overflown) {\n                    this.overflown = true;\n                    this.onOverflow();\n                }\n            }\n            else {\n                this.callback(e);\n            }\n        });\n        this.queue = [];\n        this.lastFlushTime = new Date().getTime();\n    }\n    /**\n     * @return {boolean} Whether too many output events were generated\n     */\n    hasOverflow() {\n        return this.overflown;\n    }\n    /**\n     * @return {Array<BackendEvent>} The events that happened after overflow\n     */\n    getOverflow() {\n        return this.overflow;\n    }\n    /**\n     * @param {Function} callback The event-consuming callback\n     */\n    setCallback(callback) {\n        this.callback = callback;\n    }\n}\n\n\n//# sourceURL=webpack://Papyros/./src/BackendEventQueue.ts?')},"./src/workers/javascript/JavaScriptWorker.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JavaScriptWorker: () => (/* binding */ JavaScriptWorker)\n/* harmony export */ });\n/* harmony import */ var _Backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Backend */ "./src/Backend.ts");\n/* harmony import */ var _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/lang-javascript */ "./node_modules/@codemirror/lang-javascript/dist/index.js");\n/* harmony import */ var _BackendEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../BackendEvent */ "./src/BackendEvent.ts");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n/**\n * Implementation of a JavaScript backend for Papyros\n * by using eval and overriding some builtins\n */\nclass JavaScriptWorker extends _Backend__WEBPACK_IMPORTED_MODULE_0__.Backend {\n    /**\n     * Convert varargs to a string, similar to how the console does it\n     * @param {any[]} args The values to join into a string\n     * @return {string} The string representation\n     */\n    static stringify(...args) {\n        const asString = args.map(a => {\n            if (Array.isArray(a)) {\n                return JSON.stringify(a);\n            }\n            else if (typeof (a) === "string") {\n                return a;\n            }\n            else if (typeof a === "number") {\n                return a + "";\n            }\n            else if (typeof (a) === "object" && "toString" in a) {\n                let aString = a.toString();\n                if (aString === "[object Object]") { // useless toString, so use JSON\n                    aString = JSON.stringify(a);\n                }\n                return aString;\n            }\n            else {\n                return JSON.stringify(args);\n            }\n        }).join(" ");\n        return asString;\n    }\n    /**\n     * Prompt the user for input with a message\n     * @param {string} text The message to show when asking for input\n     * @return {string} The value the user gave\n     */\n    prompt(text = "") {\n        return this.onEvent({\n            type: _BackendEvent__WEBPACK_IMPORTED_MODULE_1__.BackendEventType.Input,\n            data: text,\n            contentType: "text/plain"\n        });\n    }\n    /**\n     * Print values to the output screen\n     * @param {any[]} args The values to log\n     */\n    consoleLog(...args) {\n        this.queue.put(_BackendEvent__WEBPACK_IMPORTED_MODULE_1__.BackendEventType.Output, JavaScriptWorker.stringify(...args) + "\\n", "text/plain");\n    }\n    /**\n     * Print values to the error screen\n     * @param {any[]} args The error values to log\n     */\n    consoleError(...args) {\n        this.queue.put(_BackendEvent__WEBPACK_IMPORTED_MODULE_1__.BackendEventType.Error, JavaScriptWorker.stringify(...args) + "\\n", "text/plain");\n    }\n    autocomplete(context) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const completePropertyAfter = ["PropertyName", ".", "?."];\n            const dontCompleteIn = ["TemplateString", "LineComment", "BlockComment",\n                "VariableDefinition", "PropertyDefinition"];\n            const nodeBefore = _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascriptLanguage.parser.parse(context.text)\n                .resolveInner(context.pos, -1);\n            const globalWindow = self;\n            if (completePropertyAfter.includes(nodeBefore.name) &&\n                ((_a = nodeBefore.parent) === null || _a === void 0 ? void 0 : _a.name) == "MemberExpression") {\n                const object = nodeBefore.parent.getChild("Expression");\n                if ((object === null || object === void 0 ? void 0 : object.name) == "VariableName") {\n                    const from = /\\./.test(nodeBefore.name) ? nodeBefore.to : nodeBefore.from;\n                    const variableName = context.text.slice(object.from, object.to);\n                    if (typeof globalWindow[variableName] == "object") {\n                        return JavaScriptWorker.completeProperties(from, globalWindow);\n                    }\n                }\n            }\n            else if (nodeBefore.name == "VariableName") {\n                return JavaScriptWorker.completeProperties(nodeBefore.from, globalWindow);\n            }\n            else if (context.explicit && !dontCompleteIn.includes(nodeBefore.name)) {\n                return JavaScriptWorker.completeProperties(context.pos, globalWindow);\n            }\n            return null;\n        });\n    }\n    /**\n     * Helper method to generate suggestions based on properties in an object\n     * @param {number} from Where in the document the autocompletion starts\n     * @param {any} object Object with properties that might be relevant\n     * @return {CompletionResult} Autocompletion suggestions\n     */\n    static completeProperties(from, object) {\n        const options = Object.keys(object).map(name => {\n            return {\n                label: name,\n                type: typeof object[name] === "function" ? "function" : "variable"\n            };\n        });\n        return {\n            from,\n            options,\n            validFor: /^[\\w$]*$/\n        };\n    }\n    runCode(extras, code) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.extras = extras;\n            this.queue.reset();\n            // Builtins to store before execution and restore afterwards\n            // Workers do not have access to prompt\n            const oldContent = {\n                "console.log": console.log,\n                "console.error": console.error\n            };\n            // Overrides for the builtins\n            const newContext = {\n                "prompt": this.prompt.bind(this),\n                "console.log": this.consoleLog.bind(this),\n                "console.error": this.consoleError.bind(this)\n            };\n            // Override the builtins\n            new Function("ctx", Object.keys(newContext).map(k => `${k} = ctx[\'${k}\'];`).join("\\n"))(newContext);\n            let result = null;\n            try { // run the user\'s code\n                this.onEvent({\n                    type: _BackendEvent__WEBPACK_IMPORTED_MODULE_1__.BackendEventType.Start,\n                    contentType: "text/plain",\n                    data: "RunCode"\n                });\n                result = yield eval(code);\n            }\n            catch (error) { // try to create a friendly traceback\n                Error.captureStackTrace(error);\n                result = yield this.onEvent({\n                    type: _BackendEvent__WEBPACK_IMPORTED_MODULE_1__.BackendEventType.Error,\n                    contentType: "application/json",\n                    data: {\n                        name: error.constructor.name,\n                        what: error.message,\n                        traceback: error.stack\n                    }\n                });\n            }\n            finally { // restore the old builtins\n                new Function("ctx", Object.keys(oldContent).map(k => `${k} = ctx[\'${k}\'];`).join("\\n"))(oldContent);\n                this.queue.flush();\n                this.onEvent({\n                    type: _BackendEvent__WEBPACK_IMPORTED_MODULE_1__.BackendEventType.End,\n                    contentType: "text/plain",\n                    data: "CodeFinished"\n                });\n            }\n            return result;\n        });\n    }\n    lintCode() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve([]);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://Papyros/./src/workers/javascript/JavaScriptWorker.ts?')},"./src/workers/javascript/worker.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");\n/* harmony import */ var _JavaScriptWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JavaScriptWorker */ "./src/workers/javascript/JavaScriptWorker.ts");\n\n\nconst worker = new _JavaScriptWorker__WEBPACK_IMPORTED_MODULE_0__.JavaScriptWorker();\ncomlink__WEBPACK_IMPORTED_MODULE_1__.expose(worker);\n\n\n//# sourceURL=webpack://Papyros/./src/workers/javascript/worker.ts?')}},__webpack_module_cache__={},deferred,next;function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.x=()=>{var e=__webpack_require__.O(void 0,["vendors-node_modules_comsync_dist_index_js","vendors-node_modules_codemirror_lang-javascript_dist_index_js"],(()=>__webpack_require__("./src/workers/javascript/worker.ts")));return e=__webpack_require__.O(e)},deferred=[],__webpack_require__.O=(e,n,t,r)=>{if(!n){var o=1/0;for(s=0;s<deferred.length;s++){for(var[n,t,r]=deferred[s],a=!0,_=0;_<n.length;_++)(!1&r||o>=r)&&Object.keys(__webpack_require__.O).every((e=>__webpack_require__.O[e](n[_])))?n.splice(_--,1):(a=!1,r<o&&(o=r));if(a){deferred.splice(s--,1);var i=t();void 0!==i&&(e=i)}}return e}r=r||0;for(var s=deferred.length;s>0&&deferred[s-1][2]>r;s--)deferred[s]=deferred[s-1];deferred[s]=[n,t,r]},__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.f={},__webpack_require__.e=e=>Promise.all(Object.keys(__webpack_require__.f).reduce(((n,t)=>(__webpack_require__.f[t](e,n),n)),[])),__webpack_require__.u=e=>e+".js",__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;__webpack_require__.g.importScripts&&(e=__webpack_require__.g.location+"");var n=__webpack_require__.g.document;if(!e&&n&&(n.currentScript&&(e=n.currentScript.src),!e)){var t=n.getElementsByTagName("script");if(t.length)for(var r=t.length-1;r>-1&&!e;)e=t[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=e})(),(()=>{var e={src_workers_javascript_worker_ts:1};__webpack_require__.f.i=(n,t)=>{e[n]||importScripts(__webpack_require__.p+__webpack_require__.u(n))};var n=self.webpackChunkPapyros=self.webpackChunkPapyros||[],t=n.push.bind(n);n.push=n=>{var[r,o,a]=n;for(var _ in o)__webpack_require__.o(o,_)&&(__webpack_require__.m[_]=o[_]);for(a&&a(__webpack_require__);r.length;)e[r.pop()]=1;t(n)}})(),next=__webpack_require__.x,__webpack_require__.x=()=>Promise.all([__webpack_require__.e("vendors-node_modules_comsync_dist_index_js"),__webpack_require__.e("vendors-node_modules_codemirror_lang-javascript_dist_index_js")]).then(next);var __webpack_exports__=__webpack_require__.x();return __webpack_exports__})()));