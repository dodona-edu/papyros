import { proxy } from "comlink";
import { SyncClient } from "comsync";
import { Backend } from "./Backend";
import { BackendEvent, BackendEventType } from "./BackendEvent";
import { BackendManager } from "./BackendManager";
import { CodeEditor } from "./editor/CodeEditor";
import {
    addPapyrosPrefix,
    APPLICATION_STATE_TEXT_ID, CODE_BUTTONS_WRAPPER_ID, DEFAULT_EDITOR_DELAY, RUN_BTN_ID,
    STATE_SPINNER_ID, STOP_BTN_ID
} from "./Constants";
import { InputManager, InputManagerRenderOptions, InputMode } from "./InputManager";
import { ProgrammingLanguage } from "./ProgrammingLanguage";
import { renderSpinningCircle } from "./util/HTMLShapes";
import {
    addListener, getElement,
    t, downloadResults, parseData
} from "./util/Util";
import {
    RenderOptions, renderWithOptions,
    renderButton, ButtonOptions, Renderable, appendClasses
} from "./util/Rendering";
import { OutputManager } from "./OutputManager";
import { DebugManager } from "./DebugManager";

interface DynamicButton {
    id: string;
    buttonHTML: string;
    onClick: () => void;
}

interface CodeRunnerRenderOptions {
    /**
     * Options for rendering the panel
     */
    statusPanelOptions: RenderOptions;
    /**
     * Options for rendering the InputManager
     */
    inputOptions: InputManagerRenderOptions;
    /**
     * Options for rendering the editor
     */
    codeEditorOptions: RenderOptions;
    /**
     * RenderOptions for the output field
     */
    outputOptions: RenderOptions;
    /**
     * Options for the rendering of the visualization
     */
    debugOptions: RenderOptions;
}

/**
 * Enum representing the possible states while processing code
 */
export enum RunState {
    Loading = "loading",
    Running = "running",
    AwaitingInput = "awaiting_input",
    Stopping = "stopping",
    Ready = "ready",
    Visualizing = "visualizing"
}

/**
 * Interface to represent information required when handling loading events
 */
export interface LoadingData {
    /**
     * List of module names that are being loaded
     */
    modules: Array<string>;
    /**
     * The status of the import
     */
    status: "loading" | "loaded" | "failed";

}
/**
 * Helper component to manage and visualize the current RunState
 */
export class CodeRunner extends Renderable<CodeRunnerRenderOptions> {
    /**
     * The currently used programming language
     */
    private programmingLanguage: ProgrammingLanguage;
    /**
     * The editor in which the code is written
     */
    public readonly editor: CodeEditor;
    /**
     * Component to request and handle input from the user
     */
    public readonly inputManager: InputManager;
    /**
     * Component to handle output generated by the user's code
     */
    public readonly outputManager: OutputManager;
    /**
     * Component to handle the visualization of the user's code
     */
    public readonly debugManager: DebugManager;
    /**
     * The backend that executes the code asynchronously
     */
    private backend: Promise<SyncClient<Backend>>;
    /**
     * Current state of the program
     */
    private state: RunState;
    /**
     * Buttons managed by this component
     */
    private buttons: Array<DynamicButton>;

    /**
     * Array of packages that are being installed
     */
    private loadingPackages: Array<string>;
    /**
     * Previous state to restore when loading is done
     */
    private previousState: RunState;
    /**
     * Time at which the setState call occurred
     */
    private runStartTime: number;
    private visualize: boolean;

    /**
     * Construct a new RunStateManager with the given listeners
     * @param {ProgrammingLanguage} programmingLanguage The language to use
     * @param {InputMode} inputMode The input mode to use
     * @param {visualize} visualize Whether or not to visualize the code
     */
    constructor(programmingLanguage: ProgrammingLanguage,
        inputMode: InputMode, visualize: boolean) {
        super();
        this.programmingLanguage = programmingLanguage;
        this.visualize = visualize;
        this.editor = new CodeEditor(() => {
            if (this.state === RunState.Ready) {
                this.runCode(this.editor.getText());
            }
        });
        this.inputManager = new InputManager(async (input: string) => {
            const backend = await this.backend;
            backend.writeMessage(input);
            // Push the input to the visualizer
            backend.workerProxy.pushInput(input);
            this.setState(RunState.Running);
        }, inputMode);
        this.outputManager = new OutputManager();
        this.debugManager = new DebugManager();
        this.backend = Promise.resolve({} as SyncClient<Backend>);
        this.buttons = [];
        this.editor.onChange({
            onChange: async code => {
                const backend = await this.backend;
                const modes = await backend.workerProxy.runModes(code);
                modes.forEach(mode => {
                    const id = addPapyrosPrefix(mode.mode);
                    if (mode.active) {
                        this.addButton({
                            id: id,
                            buttonText: t(`Papyros.run_modes.${mode.mode}`),
                            classNames: "_tw-text-white _tw-bg-neutral-bg"
                        }, () => this.runCode(this.editor.getText(), mode.mode));
                    } else {
                        this.removeButton(id);
                    }
                });
                this.renderButtons();
            },
            delay: DEFAULT_EDITOR_DELAY
        });

        BackendManager.subscribe(BackendEventType.Input,
            () => this.setState(RunState.AwaitingInput));
        this.loadingPackages = [];
        BackendManager.subscribe(BackendEventType.Loading,
            e => this.onLoad(e));
        BackendManager.subscribe(BackendEventType.Start,
            e => this.onStart(e));
        this.previousState = RunState.Ready;
        this.runStartTime = new Date().getTime();
        this.state = RunState.Ready;
    }

    /**
     * Start the backend to enable running code
     */
    public async start(): Promise<void> {
        this.setState(RunState.Loading);
        const backend = BackendManager.getBackend(this.programmingLanguage);
        this.editor.setProgrammingLanguage(this.programmingLanguage);
        // Use a Promise to immediately enable running while downloading
        // eslint-disable-next-line no-async-promise-executor
        this.backend = new Promise(async resolve => {
            const workerProxy = backend.workerProxy;
            await workerProxy
                // Allow passing messages between worker and main thread
                .launch(
                    proxy((e: BackendEvent) => BackendManager.publish(e)),
                    proxy(() => {
                        this.outputManager.onOverflow(null);
                    })
                );
            this.editor.setCompletionSource(async context => {
                const completionContext = Backend.convertCompletionContext(context);
                return await workerProxy.autocomplete(completionContext);
            });
            this.editor.setLintingSource(
                async view => {
                    const workerDiagnostics = await workerProxy.lintCode(this.editor.getText());
                    return workerDiagnostics.map(d => {
                        const fromline = view.state.doc.line(d.lineNr);
                        const toLine = view.state.doc.line(d.endLineNr);
                        const from = Math.min(fromline.from + d.columnNr, fromline.to);
                        const to = Math.min(toLine.from + d.endColumnNr, toLine.to);
                        return { ...d, from: from, to: to };
                    });
                });
            return resolve(backend);
        });
        // await this.traceGenerator.setup();
        this.editor.focus();
        this.setState(RunState.Ready);
    }

    /**
     * Interrupt the currently running code
     * @return {Promise<void>} Promise of stopping
     */
    public async stop(): Promise<void> {
        this.setState(RunState.Stopping);
        BackendManager.publish({
            type: BackendEventType.End,
            data: "User cancelled run", contentType: "text/plain"
        });
        const backend = await this.backend;
        await backend.interrupt();
    }

    /**
     * Method that publishes an end event so the managers can clean themselves up
     */
    public stopVisualization(): void {
        this.setState(RunState.Stopping);
        BackendManager.publish({
            type: BackendEventType.End,
            data: "VizFinished", contentType: "text/plain"
        });
        this.setState(RunState.Ready);
    }

    /**
     * Set the used programming language to the given one to allow editing and running code
     * @param {ProgrammingLanguage} programmingLanguage The language to use
     */
    public async setProgrammingLanguage(programmingLanguage: ProgrammingLanguage): Promise<void> {
        if (this.programmingLanguage !== programmingLanguage) { // Expensive, so ensure it is needed
            await this.backend.then(b => b.interrupt());
            this.programmingLanguage = programmingLanguage;
            await this.start();
        }
    }

    /**
     * @return {ProgrammingLanguage} The current programming language
     */
    public getProgrammingLanguage(): ProgrammingLanguage {
        return this.programmingLanguage;
    }

    /**
     * @return {boolean} the current visualize state
     */
    public getVisualize(): boolean {
        return this.visualize;
    }

    /**
     * @param {state} state whether or not to visualize the code
     */
    public setVisualize(state: boolean): void {
        this.visualize = state;
        if (!this.visualize) {
            this.stopVisualization();
        }
    }

    /**
     * Show or hide the spinning circle, representing a running animation
     * @param {boolean} show Whether to show the spinner
     */
    private showSpinner(show: boolean): void {
        getElement(STATE_SPINNER_ID).style.display = show ? "" : "none";
    }

    /**
     * Show the current state of the program to the user
     * @param {RunState} state The current state of the run
     * @param {string} message Optional message to indicate the state
     */
    public setState(state: RunState, message?: string): void {
        getElement(APPLICATION_STATE_TEXT_ID).innerText =
            message || t(`Papyros.states.${state}`);
        if (state !== this.state) {
            this.previousState = this.state;
            this.state = state;
        }
        this.showSpinner(this.state !== RunState.Ready);
        this.renderButtons();
    }

    /**
     * @return {RunState} The state of the current run
     */
    public getState(): RunState {
        return this.state;
    }

    /**
     * Remove a button from the internal button list. Requires a re-render to update
     * @param {string} id Identifier of the button to remove
     */
    private removeButton(id: string): void {
        const existingIndex = this.buttons.findIndex(b => b.id === id);
        if (existingIndex !== -1) {
            this.buttons.splice(existingIndex, 1);
        }
    }

    /**
     * Add a button to display to the user
     * @param {ButtonOptions} options Options for rendering the button
     * @param {function} onClick Listener for click events on the button
     */
    public addButton(options: ButtonOptions, onClick: () => void): void {
        this.removeButton(options.id);
        this.buttons.push({
            id: options.id,
            buttonHTML: renderButton(options),
            onClick: onClick
        });
    }

    /**
     * Generate a button that the user can click to process code
     * Can either run the code or interrupt it if already running
     * @return {DynamicButton} A button to interact with the code according to the current state
     */
    private getCodeActionButton(): DynamicButton {
        let buttonOptions: ButtonOptions;
        let buttonHandler: () => void;
        if ([RunState.Ready, RunState.Loading].includes(this.state)) {
            buttonOptions = {
                id: RUN_BTN_ID,
                buttonText: t("Papyros.run"),
                classNames: "_tw-text-white _tw-bg-blue-500"
            };
            buttonHandler = () => {
                const code = this.editor.getText();
                this.runCode(code).then(() => {
                    if (this.visualize) this.generateTrace(code);
                });
            };
        } else if (this.state === RunState.Visualizing) {
            buttonOptions = {
                id: STOP_BTN_ID,
                buttonText: t("Papyros.stop"),
                classNames: "_tw-text-white _tw-bg-red-500"
            };
            buttonHandler = () => this.stopVisualization();
        } else {
            buttonOptions = {
                id: STOP_BTN_ID,
                buttonText: t("Papyros.stop"),
                classNames: "_tw-text-white _tw-bg-red-500"
            };
            buttonHandler = () => this.stop();
        }
        appendClasses(buttonOptions, "_tw-min-w-[60px]");
        return {
            id: buttonOptions.id,
            buttonHTML: renderButton(buttonOptions),
            onClick: buttonHandler
        };
    }

    /**
     * Specific helper method to render only the buttons required by the user
     */
    private renderButtons(): void {
        const buttons = [
            this.getCodeActionButton(),
            ...this.buttons
        ];
        getElement(CODE_BUTTONS_WRAPPER_ID).innerHTML =
            buttons.map(b => b.buttonHTML).join("\n");
        // Buttons are freshly added to the DOM, so attach listeners now
        buttons.forEach(b => addListener(b.id, b.onClick, "click"));
    }

    protected override _render(options: CodeRunnerRenderOptions): HTMLElement {
        appendClasses(options.statusPanelOptions,
            // eslint-disable-next-line max-len
            "_tw-border-solid _tw-border-gray-200 _tw-border-b-2 dark:_tw-border-dark-mode-content");
        const rendered = renderWithOptions(options.statusPanelOptions, `
<div class="_tw-grid _tw-grid-cols-2 _tw-items-center _tw-px-1">
    <div id="${CODE_BUTTONS_WRAPPER_ID}" class="_tw-col-span-1 _tw-flex _tw-flex-row">
    </div>
    <div class="_tw-col-span-1 _tw-flex _tw-flex-row-reverse _tw-items-center">
        <div id="${APPLICATION_STATE_TEXT_ID}"></div>
        ${renderSpinningCircle(STATE_SPINNER_ID, "_tw-border-gray-200 _tw-border-b-red-500")}
    </div>
</div>`);
        this.setState(this.state);
        this.inputManager.render(options.inputOptions);
        this.outputManager.render(options.outputOptions);
        this.debugManager.render(options.debugOptions);
        this.editor.render(options.codeEditorOptions);
        this.editor.setPanel(rendered);
        // Set language again to update the placeholder
        this.editor.setProgrammingLanguage(this.programmingLanguage);
        return rendered;
    }

    /**
     * @param {string} code The code to run
     * @param {string} mode The mode to run with
     * @return {Promise<void>} Promise of running the code
     */
    public async runCode(code: string, mode?: string): Promise<void> {
        // Setup pre-run
        this.setState(RunState.Loading);
        // Ensure we go back to Loading after finishing any remaining installs
        this.previousState = RunState.Loading;
        // Delete the previous seen input
        BackendManager.publish({
            type: BackendEventType.Start,
            data: "StartClicked", contentType: "text/plain"
        });
        let interrupted = false;
        let terminated = false;
        const backend = await this.backend;
        backend.workerProxy.clearInput();
        this.runStartTime = new Date().getTime();
        try {
            await backend.call(
                backend.workerProxy.runCode, code, mode
            );
        } catch (error: any) {
            if (error.type === "InterruptError") {
                // Error signaling forceful interrupt
                interrupted = true;
                terminated = true;
            } else {
                BackendManager.publish({
                    type: BackendEventType.Error,
                    data: JSON.stringify(error),
                    contentType: "text/json"
                });
                BackendManager.publish({
                    type: BackendEventType.End,
                    data: "RunError", contentType: "text/plain"
                });
            }
        } finally {
            if (this.state === RunState.Stopping) {
                // Was interrupted, End message already published
                interrupted = true;
            }
            this.setState(RunState.Ready, t(
                interrupted ? "Papyros.interrupted" : "Papyros.finished",
                { time: (new Date().getTime() - this.runStartTime) / 1000 }));
            if (terminated) {
                await this.start();
            } else if (await backend.workerProxy.hasOverflow()) {
                this.outputManager.onOverflow(async () => {
                    const backend = await this.backend;
                    const overflowResults = (await backend.workerProxy.getOverflow())
                        .map(e => e.data).join("");
                    downloadResults(
                        overflowResults,
                        "overflow-results.txt"
                    );
                });
            }
        }
    }

    /**
     * @param {string} code The code to generate the trace for
     * @param {string} mode The mode to run the trace generation for
     * @return {Promise<string>} Promise of the resulting trace code
     */
    public async generateTrace(code: string, mode?: string): Promise<void> {
        // Setup pre-run
        this.setState(RunState.Loading);
        // Ensure we go back to Loading after finishing any remaining installs
        this.previousState = RunState.Loading;
        BackendManager.publish({
            type: BackendEventType.StartTraceGeneration, // Temporarily keep this
            data: "VisualizeClicked", contentType: "text/plain"
        });
        let interrupted = false;
        let terminated = false;
        const backend = await this.backend;
        this.runStartTime = new Date().getTime();
        try {
            await backend.call(
                backend.workerProxy.generateTraceCode, code, mode
            );
            // this.visualizeCode(code, mode);
        } catch (error: any) {
            if (error.type === "InterruptError") {
                // Error signaling forceful interrupt
                interrupted = true;
                terminated = true;
            } else {
                BackendManager.publish({
                    type: BackendEventType.Error,
                    data: JSON.stringify(error),
                    contentType: "text/json"
                });
                BackendManager.publish({
                    type: BackendEventType.CompletedTraceGeneration,
                    data: "VisualizeError", contentType: "text/plain"
                });
            }
        } finally {
            if (this.state === RunState.Stopping) {
                // Was interrupted, End message already published
                interrupted = true;
            }
            if (this.visualize) {
                this.setState(RunState.Visualizing);
            } else {
                this.setState(RunState.Ready, t(
                    interrupted ? "Papyros.interrupted" : "Papyros.finished",
                    { time: (new Date().getTime() - this.runStartTime) / 1000 }));
            }
            if (terminated) {
                await this.start();
            } else if (await backend.workerProxy.hasOverflow()) {
                this.outputManager.onOverflow(async () => {
                    const backend = await this.backend;
                    const overflowResults = (await backend.workerProxy.getOverflow())
                        .map(e => e.data).join("");
                    downloadResults(
                        overflowResults,
                        "overflow-results.txt"
                    );
                });
            }
        }
    }

    /**
     * Callback to handle loading events
     * @param {BackendEvent} e The loading event
     */
    private onLoad(e: BackendEvent): void {
        const loadingData = parseData(e.data, e.contentType) as LoadingData;
        if (loadingData.status === "loading") {
            loadingData.modules.forEach(m => {
                if (!this.loadingPackages.includes(m)) {
                    this.loadingPackages.push(m);
                }
            });
        } else if (loadingData.status === "loaded") {
            loadingData.modules.forEach(m => {
                const index = this.loadingPackages.indexOf(m);
                if (index !== -1) {
                    this.loadingPackages.splice(index, 1);
                }
            });
        } else { // failed
            // If it is a true module, an Exception will be raised when running
            // So this does not need to be handled here, as it is often an incomplete package-name
            // that causes micropip to not find the correct wheel
            this.loadingPackages = [];
        }
        if (this.loadingPackages.length > 0) {
            const packageMessage = t("Papyros.loading", {
                // limit amount of package names shown
                packages: this.loadingPackages.slice(0, 3).join(", ")
            });
            this.setState(RunState.Loading, packageMessage);
        } else {
            this.setState(this.previousState);
        }
    }

    private onStart(e: BackendEvent): void {
        const startData = parseData(e.data, e.contentType) as string;
        if (startData.includes("RunCode")) {
            this.runStartTime = new Date().getTime();
            this.setState(RunState.Running);
        }
    }
}
