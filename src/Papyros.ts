/* eslint-disable max-len */
import "./Papyros.css";
import { proxy, Remote } from "comlink";
import I18n from "i18n-js";
import { Backend } from "./Backend";
import { startBackend, stopBackend } from "./BackendManager";
import { CodeEditor } from "./CodeEditor";
import {
    EDITOR_WRAPPER_ID, PROGRAMMING_LANGUAGE_SELECT_ID, OUTPUT_TA_ID,
    LOCALE_SELECT_ID, INPUT_AREA_WRAPPER_ID, EXAMPLE_SELECT_ID, PANEL_WRAPPER_ID
} from "./Constants";
import { InputManager, InputMode } from "./InputManager";
import { PapyrosEvent } from "./PapyrosEvent";
import { ProgrammingLanguage } from "./ProgrammingLanguage";
import { LogType, papyrosLog } from "./util/Logging";
import {
    t, loadTranslations, getLocales,
    getSelectOptions, renderSelect, removeSelection,
    RenderOptions, renderWithOptions,
    addListener, ButtonOptions, getElement
} from "./util/Util";
import { RunState, RunStateManager } from "./RunStateManager";
import { getCodeForExample, getExampleNames } from "./examples/Examples";
import { OutputManager } from "./OutputManager";
import { makeChannel } from "sync-message";
import { RunListener } from "./RunListener";

const LANGUAGE_MAP = new Map([
    ["python", ProgrammingLanguage.Python],
    ["javascript", ProgrammingLanguage.JavaScript]
]);

/**
 * Groups values related to running code
 */
interface PapyrosCodeState {
    /**
     * The currently used programming language
     */
    programmingLanguage: ProgrammingLanguage;
    /**
     * The editor in which the code is written
     */
    editor: CodeEditor;
    /**
     * The backend that executes the code asynchronously
     */
    backend: Remote<Backend>;
    /**
     * The identifier for the current run
     */
    runId: number;
}

/**
 * Configuration options for this instance of Papyros
 */
interface PapyrosConfig {
    /**
     * Whether Papyros is run in standAlone mode or embedded in an application
     */
    standAlone: boolean;
    /**
     * The programming language to use
     */
    programmingLanguage: ProgrammingLanguage;
    /**
     * The language to use
     */
    locale: string;
    /**
     * The InputMode to use
     */
    inputMode: InputMode;
}

/**
 * Options for rendering Papyros
 */
interface PapyrosRenderOptions {
    /**
     * Options to render Papyros itself, only used in standAlone mode
     */
    standAloneOptions?: RenderOptions;
    /**
     * RenderOptions for the code editor
     */
    codeEditorOptions?: RenderOptions;
    /**
     * RenderOptions for the status panel in the editor
     */
    statusPanelOptions?: RenderOptions;
    /**
     * RenderOptions for the input field
     */
    inputOptions?: RenderOptions;
    /**
     * RenderOptions for the output field
     */
    outputOptions?: RenderOptions
}

/**
 * Class that manages multiple components to form a coding scratchpad
 */
export class Papyros {
    /**
     * Config used to initialize Papyros
     */
    config: PapyrosConfig;
    /**
     * Component to manage and visualize the state of the program
     */
    stateManager: RunStateManager;
    /**
     * Component to request and handle input from the user
     */
    inputManager: InputManager;
    /**
     * Component to handle output generated by the user's code
     */
    outputManager: OutputManager;
    /**
     * Groups all internal properties related to running code
     */
    codeState: PapyrosCodeState;
    /**
     * Listeners to changes in the running state
     */
    runListeners: Array<RunListener>;
    /**
     * Whether this instance has been launched
     */
    private launched: boolean;

    /**
     * Construct a new Papyros instance
     * @param {PapyrosConfig} config Properties to configure this instance
     */
    constructor(config: PapyrosConfig) {
        this.launched = false;
        this.runListeners = [];
        this.config = config;
        // Load translations as other components depend on them
        loadTranslations();
        I18n.locale = config.locale;

        const { programmingLanguage } = this.config;
        this.codeState = {
            programmingLanguage: programmingLanguage,
            editor: new CodeEditor(
                programmingLanguage,
                t("Papyros.code_placeholder", { programmingLanguage })),
            backend: {} as Remote<Backend>,
            runId: 0
        };
        this.outputManager = new OutputManager();
        this.stateManager = new RunStateManager(() => this.runCode(false), () => this.stop(), () => this.runCode(true));
        this.inputManager = new InputManager(() => this.stateManager.setState(RunState.Running), config.inputMode);
        this.addRunListener(this.inputManager);
        this.addRunListener(this.outputManager);
    }

    /**
     * Register a listener to be notified when code runs start or end
     * @param {RunListener} listener The new listener
     */
    addRunListener(listener: RunListener): void {
        this.runListeners.push(listener);
    }

    /**
     * Inform the listeners about the current run
     * @param {boolean} start Whether the run started or ended
     */
    private notifyListeners(start: boolean): void {
        if (start) {
            this.runListeners.forEach(l => l.onRunStart());
        } else {
            this.runListeners.forEach(l => l.onRunEnd());
        }
    }

    /**
     * Getter for the current state of the program
     */
    get state(): RunState {
        return this.stateManager.state;
    }

    /**
     * Launch this instance of Papyros, making it ready to run code
     * @return {Promise<Papyros>} Promise of launching, chainable
     */
    async launch(): Promise<Papyros> {
        if (!this.launched) {
            const start = new Date().getTime();
            await this.startBackend();
            papyrosLog(LogType.Important, `Finished loading backend after ${new Date().getTime() - start} ms`);
            this.codeState.editor.focus();
        }
        return this;
    }

    /**
     * Set the used programming language to the given one to allow editing and running code
     * @param {ProgrammingLanguage} programmingLanguage The language to use
     */
    async setProgrammingLanguage(programmingLanguage: ProgrammingLanguage): Promise<void> {
        if (this.codeState.programmingLanguage !== programmingLanguage) { // Expensive, so ensure it is needed
            stopBackend(this.codeState.backend);
            this.codeState.programmingLanguage = programmingLanguage;
            await this.startBackend();
        }
    }

    /**
     * @param {string} code The code to use in the editor
     */
    setCode(code: string): void {
        this.codeState.editor.setCode(code);
    }

    /**
     * @return {string} The currently written code
     */
    getCode(): string {
        return this.codeState.editor.getCode();
    }

    /**
     * Start up the backend for the current programming language
     */
    private async startBackend(): Promise<void> {
        const programmingLanguage = this.codeState.programmingLanguage;
        this.stateManager.setState(RunState.Loading);
        const backend = startBackend(programmingLanguage);
        this.codeState.backend = backend;
        this.codeState.editor.setLanguage(programmingLanguage,
            async context => await this.codeState.backend.autocomplete(Backend.convertCompletionContext(context)),
            t("Papyros.code_placeholder", { programmingLanguage })
        );
        // Allow passing messages between worker and main thread
        await backend.launch(proxy(e => this.onMessage(e)), this.inputManager.channel);
        this.stateManager.setState(RunState.Ready);
    }

    /**
     * Configure how user input is handled within Papyros
     * By default, we will try to use SharedArrayBuffers
     * If this option is not available, the optional arguments become relevant
     * They are needed to register a service worker to handle communication between threads
     * @param {string} serviceWorkerRoot URL for the directory where the service worker lives
     * @param {string} serviceWorkerName The name of the file containing the script
     * @param {boolean} allowReload Whether we are allowed to force a reload of the page
     * This allows using SharedArrayBuffers without configuring the HTTP headers yourself
     * @return {Promise<boolean>} Promise of configuring input
     */
    async configureInput(serviceWorkerRoot?: string, serviceWorkerName?: string,
        allowReload = false): Promise<boolean> {
        const RELOAD_STORAGE_KEY = "__papyros_reloading";
        if (allowReload && window.localStorage.getItem(RELOAD_STORAGE_KEY)) {
            // We are the result of the page reload, so we can start
            window.localStorage.removeItem(RELOAD_STORAGE_KEY);
            return true;
        } else {
            if (typeof SharedArrayBuffer === "undefined") {
                papyrosLog(LogType.Important, "SharedArrayBuffers are not available. ");
                if (!serviceWorkerRoot || !serviceWorkerName || !("serviceWorker" in navigator)) {
                    papyrosLog(LogType.Important, "Unable to register service worker. Please specify all required parameters and ensure service workers are supported.");
                    return false;
                }
                // Ensure there is a slash at the end to allow the script to be resolved
                const rootWithSlash = serviceWorkerRoot.endsWith("/") ? serviceWorkerRoot : serviceWorkerRoot + "/";
                const serviceWorkerUrl = rootWithSlash + serviceWorkerName;
                papyrosLog(LogType.Important, `Registering service worker: ${serviceWorkerUrl}`);
                await window.navigator.serviceWorker.register(serviceWorkerUrl);
                this.inputManager.channel = makeChannel({ serviceWorker: { scope: rootWithSlash } })!;
                if (allowReload) { // Store that we are reloading, to prevent the next load from doing all this again
                    window.localStorage.setItem(RELOAD_STORAGE_KEY, RELOAD_STORAGE_KEY);
                    // service worker adds new headers that may allow SharedArrayBuffers to be used
                    window.location.reload();
                }
                return true;
            } else {
                return true;
            }
        }
    }

    /**
     * Process PapyrosEvents with type="error"
     * @param {PapyrosEvent} e The error-event
     */
    private onError(e: PapyrosEvent): void {
        papyrosLog(LogType.Debug, "Got error in Papyros: ", e);
        this.outputManager.showError(e);
    }
    /**
     * Process PapyrosEvents with type="input"
     * @param {PapyrosEvent} e The input-event
     */
    private async onInput(e: PapyrosEvent): Promise<void> {
        papyrosLog(LogType.Debug, "Received onInput event in Papyros: ", e);
        this.stateManager.setState(RunState.AwaitingInput);
        await this.inputManager.onInput(e);
    }

    /**
     * Generic handler function to pass PapyrosEvents to the relevant method
     * @param {PapyrosEvent} e The event ro process
     */
    onMessage(e: PapyrosEvent): void {
        papyrosLog(LogType.Debug, "received event in onMessage", e);
        if (e.runId === this.codeState.runId) { // Only process relevant messages
            if (e.type === "output") {
                this.outputManager.showOutput(e);
            } else if (e.type === "input") {
                this.onInput(e);
            } else if (e.type === "error") {
                this.onError(e);
            }
        } else {
            papyrosLog(LogType.Debug, "Received event with outdated runId: ", e);
        }
    }

    /**
     * Run the code that is currently present in the editor
     * @param {boolean} debug Whether the run happens in debug mode
     * @return {Promise<void>} Promise of running the code
     */
    async runCode(debug: boolean): Promise<void> {
        if (this.state !== RunState.Ready) {
            papyrosLog(LogType.Error, `Run code called from invalid state: ${this.state}`);
            return;
        }
        // Setup pre-run
        this.codeState.runId += 1;
        this.stateManager.setState(RunState.Running);
        this.notifyListeners(true);

        papyrosLog(LogType.Debug, "Running code in Papyros, sending to backend");
        const start = new Date().getTime();
        try {
            const {
                backend,
                runId,
                editor
            } = this.codeState;
            if (debug) {
                console.log("Breakpoints are: ", editor.breakpointLines);
                await backend.debugCode(this.getCode(), runId, editor.breakpointLines);
            } else {
                await backend.runCode(this.getCode(), runId);
            }
        } catch (error: any) {
            this.onError(error);
        } finally {
            const end = new Date().getTime();
            this.stateManager.setState(RunState.Ready, t("Papyros.finished", { time: (end - start) / 1000 }));
            this.notifyListeners(false);
        }
    }

    /**
     * Interrupt the currently running code
     * @return {Promise<void>} Promise of stopping
     */
    async stop(): Promise<void> {
        if (![RunState.Running, RunState.AwaitingInput].includes(this.state)) {
            papyrosLog(LogType.Error, `Stop called from invalid state: ${this.state}`);
            return;
        }
        papyrosLog(LogType.Debug, "Stopping backend!");
        this.codeState.runId += 1; // ignore messages coming from last run
        this.stateManager.setState(RunState.Stopping);
        this.notifyListeners(false);
        // Since we use workers, the old one must be entirely replaced to interrupt it
        stopBackend(this.codeState.backend);
        return this.startBackend();
    }

    /**
     * Render Papyros with the given options
     * @param {PapyrosRenderOptions} renderOptions Options to use
     */
    render(renderOptions: PapyrosRenderOptions): void {
        // Set default values for each option
        renderOptions.inputOptions = Object.assign({ parentElementId: INPUT_AREA_WRAPPER_ID }, renderOptions.inputOptions);
        renderOptions.statusPanelOptions = Object.assign({ parentElementId: PANEL_WRAPPER_ID }, renderOptions.statusPanelOptions);
        renderOptions.codeEditorOptions = Object.assign({ parentElementId: EDITOR_WRAPPER_ID }, renderOptions.codeEditorOptions);
        renderOptions.outputOptions = Object.assign({ parentElementId: OUTPUT_TA_ID }, renderOptions.outputOptions);

        if (this.config.standAlone) {
            const {
                locale, programmingLanguage
            } = this.config;
            const programmingLanguageSelect =
                renderSelect(PROGRAMMING_LANGUAGE_SELECT_ID, new Array(...LANGUAGE_MAP.values()),
                    l => t(`Papyros.programming_languages.${l}`), programmingLanguage, t("Papyros.programming_language"));
            const exampleSelect =
                renderSelect(EXAMPLE_SELECT_ID, getExampleNames(programmingLanguage),
                    name => name, undefined, t("Papyros.examples"));
            const locales = [locale, ...getLocales().filter(l => l != locale)];
            const localeSelect = `
            <div class="flex flex-row-reverse">
                <!-- row-reverse to start at the right, so put elements in order of display -->
                ${renderSelect(LOCALE_SELECT_ID, locales, l => t(`Papyros.locales.${l}`), locale)}
                <i class="mdi mdi-web text-4xl text-white"></i>
            </div>
            `;
            const navBar = `
            <div class="bg-blue-500 text-white text-lg p-4 grid grid-cols-8 items-center max-h-1/5">
                <div class="col-span-6">
                    ${t("Papyros.Papyros")}
                </div>
                <div class="col-span-2 text-black">
                    ${localeSelect}
                </div>
            </div>
            `;
            const header = `
            <!-- Header -->
            <div class="flex flex-row items-center">
                ${programmingLanguageSelect}
                ${exampleSelect}
            </div>`;
            renderWithOptions(renderOptions.standAloneOptions!, `
    <div id="papyros" class="max-h-screen h-full overflow-y-hidden">
        ${navBar}
        <div class="m-10">
            ${header}
            <!--Body of the application-->
            <div class="grid grid-cols-2 gap-4 box-border max-h-full">
                <!-- Code section-->
                <div>
                    <h1>${t("Papyros.code")}:</h1>
                    <div id="${renderOptions.codeEditorOptions.parentElementId}"></div>
                    <div id="${renderOptions.statusPanelOptions.parentElementId}"></div>
                </div>
                <!-- User input and output section-->
                <div>
                    <h1>${t("Papyros.output")}:</h1>
                    <div id="${renderOptions.outputOptions.parentElementId}"></div>
                    <h1>${t("Papyros.input")}:</h1>
                    <div id="${renderOptions.inputOptions.parentElementId}"></div>
                </div>
            </div>
        </div>
    </div>
    `);
            addListener<ProgrammingLanguage>(
                PROGRAMMING_LANGUAGE_SELECT_ID, pl => {
                    this.setProgrammingLanguage(pl);
                    getElement<HTMLSelectElement>(EXAMPLE_SELECT_ID).innerHTML =
                        getSelectOptions(getExampleNames(pl), name => name);
                    removeSelection(EXAMPLE_SELECT_ID);
                    // Modify search query params without reloading page
                    history.pushState(null, "", `?locale=${I18n.locale}&language=${pl}`);
                }
            );
            addListener(LOCALE_SELECT_ID, locale => {
                document.location.href = `?locale=${locale}&language=${this.codeState.programmingLanguage}`;
            });
            addListener(EXAMPLE_SELECT_ID, name => {
                const code = getCodeForExample(this.codeState.programmingLanguage, name);
                this.setCode(code);
            }, "input");
            // Ensure there is no initial selection
            removeSelection(EXAMPLE_SELECT_ID);
        }

        this.inputManager.render(renderOptions.inputOptions);
        const runStatePanel = this.stateManager.render(renderOptions.statusPanelOptions);
        this.codeState.editor.render(renderOptions.codeEditorOptions, runStatePanel);
        this.outputManager.render(renderOptions.outputOptions);
    }

    /**
     * Add a button to the status panel within Papyros
     * @param {ButtonOptions} options Options to render the button with
     * @param {function} onClick Listener for click events on the button
     */
    addButton(options: ButtonOptions, onClick: () => void): void {
        this.stateManager.addButton(options, onClick);
    }

    /**
     * @param {ProgrammingLanguage} language The language to check
     * @return {boolean} Whether Papyros supports this language by default
     */
    static supportsProgrammingLanguage(language: string): boolean {
        return Papyros.toProgrammingLanguage(language) !== undefined;
    }

    /**
     * Convert a string to a ProgrammingLanguage
     * @param {string} language The language to convert
     * @return {ProgrammingLanguage | undefined} The ProgrammingLanguage, or undefined if not supported
     */
    static toProgrammingLanguage(language: string): ProgrammingLanguage | undefined {
        return LANGUAGE_MAP.get(language.toLowerCase());
    }
}
