/* eslint-disable max-len */
import "./Papyros.css";
import I18n from "i18n-js";
import {
    EDITOR_WRAPPER_ID, PROGRAMMING_LANGUAGE_SELECT_ID, OUTPUT_TA_ID,
    LOCALE_SELECT_ID, INPUT_AREA_WRAPPER_ID, EXAMPLE_SELECT_ID, PANEL_WRAPPER_ID, DARK_MODE_TOGGLE_ID, MAIN_APP_ID
} from "./Constants";
import { InputMode } from "./InputManager";
import { ProgrammingLanguage } from "./ProgrammingLanguage";
import { LogType, papyrosLog } from "./util/Logging";
import {
    t, loadTranslations, getLocales,
    getSelectOptions, removeSelection,
    addListener, getElement
} from "./util/Util";
import { RunState, CodeRunner } from "./CodeRunner";
import { getCodeForExample, getExampleNames } from "./examples/Examples";
import { OutputManager } from "./OutputManager";
import { makeChannel } from "sync-message";
import { BackendManager } from "./BackendManager";
import { RenderOptions, renderWithOptions, renderSelect, ButtonOptions, Renderable } from "./util/Rendering";

const LANGUAGE_MAP = new Map([
    ["python", ProgrammingLanguage.Python],
    ["javascript", ProgrammingLanguage.JavaScript]
]);

/**
 * Configuration options for this instance of Papyros
 */
interface PapyrosConfig {
    /**
     * Whether Papyros is run in standAlone mode or embedded in an application
     */
    standAlone: boolean;
    /**
     * The programming language to use
     */
    programmingLanguage: ProgrammingLanguage;
    /**
     * The language to use
     */
    locale: string;
    /**
     * The InputMode to use
     */
    inputMode: InputMode;
}

/**
 * Options for rendering Papyros
 */
interface PapyrosRenderOptions {
    /**
     * Options to render Papyros itself, only used in standAlone mode
     */
    standAloneOptions?: RenderOptions;
    /**
     * RenderOptions for the code editor
     */
    codeEditorOptions?: RenderOptions;
    /**
     * RenderOptions for the status panel in the editor
     */
    statusPanelOptions?: RenderOptions;
    /**
     * RenderOptions for the input field
     */
    inputOptions?: RenderOptions;
    /**
     * RenderOptions for the output field
     */
    outputOptions?: RenderOptions;
    /**
     * Whether to render in dark mode
     */
    darkMode?: boolean;
}

/**
 * Class that manages multiple components to form a coding scratchpad
 */
export class Papyros extends Renderable<PapyrosRenderOptions> {
    /**
     * Config used to initialize Papyros
     */
    config: PapyrosConfig;
    /**
     * Component to run code entered by the user
     */
    codeRunner: CodeRunner;
    /**
     * Component to handle output generated by the user's code
     */
    outputManager: OutputManager;
    /**
     * Whether this instance has been launched
     */
    private launched: boolean;

    /**
     * Construct a new Papyros instance
     * @param {PapyrosConfig} config Properties to configure this instance
     */
    constructor(config: PapyrosConfig) {
        super();
        this.launched = false;
        this.config = config;
        // Load translations as other components depend on them
        loadTranslations();
        I18n.locale = config.locale;

        const { programmingLanguage } = this.config;
        this.outputManager = new OutputManager();
        this.codeRunner = new CodeRunner(programmingLanguage);
    }

    /**
     * @return {RunState} The current state of the user's code
     */
    getState(): RunState {
        return this.codeRunner.getState();
    }

    /**
     * Launch this instance of Papyros, making it ready to run code
     * @return {Promise<Papyros>} Promise of launching, chainable
     */
    async launch(): Promise<Papyros> {
        if (!this.launched) {
            await this.codeRunner.start();
        }
        return this;
    }

    /**
     * Set the used programming language to the given one to allow editing and running code
     * @param {ProgrammingLanguage} programmingLanguage The language to use
     */
    async setProgrammingLanguage(programmingLanguage: ProgrammingLanguage): Promise<void> {
        await this.codeRunner.setProgrammingLanguage(programmingLanguage);
    }

    /**
     * @param {string} locale The locale to use
     */
    setLocale(locale: string): void {
        if (locale !== I18n.locale) {
            I18n.locale = locale;
            this.config.locale = locale;
            this.render();
        }
    }

    /**
     * @param {boolean} darkMode Whether to use dark mode
     */
    setDarkMode(darkMode: boolean): void {
        if (darkMode !== this.renderOptions.darkMode) {
            this.renderOptions.darkMode = darkMode;
            this.render();
        }
    }

    /**
     * @param {string} code The code to use in the editor
     */
    setCode(code: string): void {
        this.codeRunner.editor.setCode(code);
    }

    /**
     * @return {string} The currently written code
     */
    getCode(): string {
        return this.codeRunner.editor.getCode();
    }

    /**
     * Configure how user input is handled within Papyros
     * By default, we will try to use SharedArrayBuffers
     * If this option is not available, the optional arguments become relevant
     * They are needed to register a service worker to handle communication between threads
     * @param {string} serviceWorkerRoot URL for the directory where the service worker lives
     * @param {string} serviceWorkerName The name of the file containing the script
     * @param {boolean} allowReload Whether we are allowed to force a reload of the page
     * This allows using SharedArrayBuffers without configuring the HTTP headers yourself
     * @return {Promise<boolean>} Promise of configuring input
     */
    async configureInput(serviceWorkerRoot?: string, serviceWorkerName?: string)
        : Promise<boolean> {
        if (typeof SharedArrayBuffer === "undefined") {
            papyrosLog(LogType.Important, "SharedArrayBuffers are not available. ");
            if (!serviceWorkerRoot || !serviceWorkerName || !("serviceWorker" in navigator)) {
                papyrosLog(LogType.Important, "Unable to register service worker. Please specify all required parameters and ensure service workers are supported.");
                return false;
            }
            // Ensure there is a slash at the end to allow the script to be resolved
            const rootWithSlash = serviceWorkerRoot.endsWith("/") ? serviceWorkerRoot : serviceWorkerRoot + "/";
            const serviceWorkerUrl = rootWithSlash + serviceWorkerName;
            papyrosLog(LogType.Important, `Registering service worker: ${serviceWorkerUrl}`);
            await window.navigator.serviceWorker.register(serviceWorkerUrl);
            BackendManager.channel = makeChannel({ serviceWorker: { scope: rootWithSlash } })!;
        }
        return true;
    }

    protected override _render(renderOptions: PapyrosRenderOptions): void {
        // Set default values for each option
        for (const [option, defaultParentId] of [
            ["inputOptions", INPUT_AREA_WRAPPER_ID], ["statusPanelOptions", PANEL_WRAPPER_ID],
            ["codeEditorOptions", EDITOR_WRAPPER_ID], ["outputOptions", OUTPUT_TA_ID],
            ["standAloneOptions", MAIN_APP_ID]
        ]) {
            const elementOptions: RenderOptions = (renderOptions as any)[option] || {};
            elementOptions.darkMode = renderOptions.darkMode;
            (renderOptions as any)[option] = Object.assign(
                { parentElementId: defaultParentId }, elementOptions);
        }
        if (this.config.standAlone) {
            const {
                locale, programmingLanguage
            } = this.config;
            const programmingLanguageSelect =
                renderSelect(PROGRAMMING_LANGUAGE_SELECT_ID, new Array(...LANGUAGE_MAP.values()),
                    l => t(`Papyros.programming_languages.${l}`), programmingLanguage, t("Papyros.programming_language"));
            const exampleSelect =
                renderSelect(EXAMPLE_SELECT_ID, getExampleNames(programmingLanguage),
                    name => name, undefined, t("Papyros.examples"));
            const locales = [locale, ...getLocales().filter(l => l != locale)];
            const localeSelect = `
            <div class="flex flex-row-reverse">
                <!-- row-reverse to start at the right, so put elements in order of display -->
                ${renderSelect(LOCALE_SELECT_ID, locales, l => t(`Papyros.locales.${l}`), locale)}
                <i class="mdi mdi-web text-4xl text-white"></i>
            </div>
            `;
            const darkModeToggle = `
            <a id=${DARK_MODE_TOGGLE_ID} class="text-white hover:cursor-pointer">
            ${t(`Papyros.toggle_dark_mode.${!renderOptions.darkMode}`)}
            </a>`;
            const navBar = `
            <div class="bg-blue-500 text-white text-lg p-4 grid grid-cols-8 items-center max-h-1/5">
                <div class="col-span-6">
                    ${t("Papyros.Papyros")}
                </div>
                <div class="col-span-2 text-black">
                    ${localeSelect}
                    ${darkModeToggle}
                </div>

            </div>
            `;
            const header = `
            <!-- Header -->
            <div class="flex flex-row items-center">
                ${programmingLanguageSelect}
                ${exampleSelect}
            </div>`;
            renderWithOptions(renderOptions.standAloneOptions!, `
    <div id="${MAIN_APP_ID}" class="max-h-screen h-full overflow-y-hidden">
        ${navBar}
        <div class="m-10">
            ${header}
            <!--Body of the application-->
            <div class="grid grid-cols-2 gap-4 box-border max-h-full">
                <!-- Code section-->
                <div>
                    <h1>${t("Papyros.code")}:</h1>
                    <div id="${renderOptions.codeEditorOptions!.parentElementId}"></div>
                    <div id="${renderOptions.statusPanelOptions!.parentElementId}"></div>
                </div>
                <!-- User input and output section-->
                <div>
                    <h1>${t("Papyros.output")}:</h1>
                    <div id="${renderOptions.outputOptions!.parentElementId}"></div>
                    <h1>${t("Papyros.input")}:</h1>
                    <div id="${renderOptions.inputOptions!.parentElementId}"></div>
                </div>
            </div>
        </div>
    </div>
    `);
            addListener<ProgrammingLanguage>(
                PROGRAMMING_LANGUAGE_SELECT_ID, pl => {
                    this.setProgrammingLanguage(pl);
                    getElement<HTMLSelectElement>(EXAMPLE_SELECT_ID).innerHTML =
                        getSelectOptions(getExampleNames(pl), name => name);
                    removeSelection(EXAMPLE_SELECT_ID);
                    // Modify search query params without reloading page
                    history.pushState(null, "", `?locale=${I18n.locale}&language=${pl}`);
                }, "change", "value"
            );
            addListener(LOCALE_SELECT_ID, locale => {
                // Modify search query params without reloading page
                history.pushState(null, "", `?locale=${locale}&language=${this.codeRunner.getProgrammingLanguage()}`);
                this.setLocale(locale);
            }, "change", "value");
            addListener(EXAMPLE_SELECT_ID, name => {
                const code = getCodeForExample(this.codeRunner.getProgrammingLanguage(), name);
                this.setCode(code);
            }, "change", "value");
            // Ensure there is no initial selection
            removeSelection(EXAMPLE_SELECT_ID);
            addListener(DARK_MODE_TOGGLE_ID, () => {
                this.setDarkMode(!renderOptions.darkMode);
            }, "click");
        }
        this.codeRunner.render({
            statusPanelOptions: renderOptions.statusPanelOptions!,
            inputOptions: renderOptions.inputOptions!,
            codeEditorOptions: renderOptions.codeEditorOptions!
        });
        this.outputManager.render(renderOptions.outputOptions!);
    }

    /**
     * Add a button to the status panel within Papyros
     * @param {ButtonOptions} options Options to render the button with
     * @param {function} onClick Listener for click events on the button
     */
    addButton(options: ButtonOptions, onClick: () => void): void {
        this.codeRunner.addButton(options, onClick);
    }

    /**
     * @param {ProgrammingLanguage} language The language to check
     * @return {boolean} Whether Papyros supports this language by default
     */
    static supportsProgrammingLanguage(language: string): boolean {
        return Papyros.toProgrammingLanguage(language) !== undefined;
    }

    /**
     * Convert a string to a ProgrammingLanguage
     * @param {string} language The language to convert
     * @return {ProgrammingLanguage | undefined} The ProgrammingLanguage, or undefined if not supported
     */
    static toProgrammingLanguage(language: string): ProgrammingLanguage | undefined {
        return LANGUAGE_MAP.get(language.toLowerCase());
    }
}
