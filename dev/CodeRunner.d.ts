import { RunMode } from "./Backend";
import { CodeEditor } from "./editor/CodeEditor";
import { InputManager, InputManagerRenderOptions, InputMode } from "./InputManager";
import { ProgrammingLanguage } from "./ProgrammingLanguage";
import { ButtonOptions, Renderable, RenderOptions } from "./util/Rendering";
import { OutputManager } from "./OutputManager";
import { Debugger } from "./Debugger";
interface CodeRunnerRenderOptions {
    /**
     * Options for rendering the panel
     */
    statusPanelOptions: RenderOptions;
    /**
     * Options for rendering the InputManager
     */
    inputOptions: InputManagerRenderOptions;
    /**
     * Options for rendering the editor
     */
    codeEditorOptions: RenderOptions;
    /**
     * RenderOptions for the output field
     */
    outputOptions: RenderOptions;
    traceOptions: RenderOptions;
}
/**
 * Enum representing the possible states while processing code
 */
export declare enum RunState {
    Loading = "loading",
    Running = "running",
    AwaitingInput = "awaiting_input",
    Stopping = "stopping",
    Ready = "ready"
}
/**
 * Interface to represent information required when handling loading events
 */
export interface LoadingData {
    /**
     * List of module names that are being loaded
     */
    modules: Array<string>;
    /**
     * The status of the import
     */
    status: "loading" | "loaded" | "failed";
}
/**
 * Helper component to manage and visualize the current RunState
 */
export declare class CodeRunner extends Renderable<CodeRunnerRenderOptions> {
    /**
     * The currently used programming language
     */
    private programmingLanguage;
    /**
     * The editor in which the code is written
     */
    readonly editor: CodeEditor;
    /**
     * Component to request and handle input from the user
     */
    readonly inputManager: InputManager;
    /**
     * Component to handle output generated by the user's code
     */
    readonly outputManager: OutputManager;
    readonly traceViewer: Debugger;
    /**
     * The backend that executes the code asynchronously
     */
    private backend;
    /**
     * Current state of the program
     */
    private state;
    /**
     * Foreign buttons inserted into this component
     */
    private userButtons;
    /**
     * Internal buttons for different run modes
     */
    private runButtons;
    /**
     * Array of packages that are being installed
     */
    private loadingPackages;
    /**
     * Previous state to restore when loading is done
     */
    private previousState;
    /**
     * Time at which the setState call occurred
     */
    private runStartTime;
    private _debugMode;
    /**
     * Construct a new RunStateManager with the given listeners
     * @param {ProgrammingLanguage} programmingLanguage The language to use
     * @param {InputMode} inputMode The input mode to use
     */
    constructor(programmingLanguage: ProgrammingLanguage, inputMode: InputMode);
    private set debugMode(value);
    private get debugMode();
    /**
     * Stops the current run and resets the state of the program
     * Regular and debug output is cleared
     * @return {Promise<void>} Returns when the program has been reset
     */
    reset(): Promise<void>;
    private updateRunButtons;
    private addRunButton;
    /**
     * Start the backend to enable running code
     */
    start(): Promise<void>;
    /**
     * Interrupt the currently running code
     * @return {Promise<void>} Returns when the code has been interrupted
     */
    stop(): Promise<void>;
    /**
     * Set the used programming language to the given one to allow editing and running code
     * @param {ProgrammingLanguage} programmingLanguage The language to use
     */
    setProgrammingLanguage(programmingLanguage: ProgrammingLanguage): Promise<void>;
    provideFiles(inlinedFiles: Record<string, string>, hrefFiles: Record<string, string>): Promise<void>;
    /**
     * @return {ProgrammingLanguage} The current programming language
     */
    getProgrammingLanguage(): ProgrammingLanguage;
    /**
     * Show or hide the spinning circle, representing a running animation
     * @param {boolean} show Whether to show the spinner
     */
    private showSpinner;
    /**
     * Show the current state of the program to the user
     * @param {RunState} state The current state of the run
     * @param {string} message Optional message to indicate the state
     */
    setState(state: RunState, message?: string): void;
    /**
     * @return {RunState} The state of the current run
     */
    getState(): RunState;
    /**
     * Remove a button from the internal button list. Requires a re-render to update
     * @param {string} id Identifier of the button to remove
     */
    private removeButton;
    /**
     * Add a button to display to the user
     * @param {ButtonOptions} options Options for rendering the button
     * @param {function} onClick Listener for click events on the button
     */
    addButton(options: ButtonOptions, onClick: () => void): void;
    /**
     * Generate a button that the user can click to process code
     * Can either run the code or interrupt it if already running
     * @return {DynamicButton} A list of buttons to interact with the code according to the current state
     */
    private getCodeActionButtons;
    /**
     * Specific helper method to render only the buttons required by the user
     * @param {DynamicButton[]} buttons The buttons to render
     * @param {string} id The id of the element to render the buttons in
     */
    private renderButtons;
    protected _render(options: CodeRunnerRenderOptions): HTMLElement;
    /**
     * Execute the code in the editor
     * @param {RunMode} mode The mode to run with
     * @return {Promise<void>} Promise of running the code
     */
    runCode(mode?: RunMode): Promise<void>;
    /**
     * Callback to handle loading events
     * @param {BackendEvent} e The loading event
     */
    private onLoad;
    private onStart;
}
export {};
