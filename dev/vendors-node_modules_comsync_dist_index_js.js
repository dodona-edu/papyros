(self.webpackChunkPapyros=self.webpackChunkPapyros||[]).push([["vendors-node_modules_comsync_dist_index_js"],{"./node_modules/comsync/dist/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('!function(e,t){ true?module.exports=t(__webpack_require__(/*! sync-message */ "./node_modules/sync-message/dist/index.js"),__webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs")):0}(self,(function(e,t){return(()=>{"use strict";var s={272:e=>{e.exports=t},746:t=>{t.exports=e}},r={};function i(e){var t=r[e];if(void 0!==t)return t.exports;var n=r[e]={exports:{}};return s[e](n,n.exports,i),n.exports}i.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return i.d(t,{a:t}),t},i.d=(e,t)=>{for(var s in t)i.o(t,s)&&!i.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{i.r(n),i.d(n,{InterruptError:()=>r,NoChannelError:()=>o,SyncClient:()=>a,syncExpose:()=>h});var e=i(746),t=i(272),s=function(e,t,s,r){return new(s||(s=Promise))((function(i,n){function o(e){try{h(r.next(e))}catch(e){n(e)}}function a(e){try{h(r.throw(e))}catch(e){n(e)}}function h(e){var t;e.done?i(e.value):(t=e.value,t instanceof s?t:new s((function(e){e(t)}))).then(o,a)}h((r=r.apply(e,t||[])).next())}))};class r extends Error{constructor(){super(...arguments),this.type="InterruptError",this.name=this.type}}class o extends Error{constructor(){super(...arguments),this.type="NoChannelError",this.name=this.type}}class a{constructor(e,t){this.workerCreator=e,this.channel=t,this.state="idle",this._messageIdBase="",this._messageIdSeq=0,this._start()}interrupt(){return s(this,void 0,void 0,(function*(){"idle"!==this.state&&("awaitingMessage"!==this.state&&"sleeping"!==this.state?this.interrupter?yield this.interrupter():(this.terminate(),this._start()):yield this._writeMessage({interrupted:!0}))}))}call(r,...i){return s(this,void 0,void 0,(function*(){if("idle"!==this.state)throw new Error(`State is ${this.state}, not idle`);let s=!0;this.state="running",this._messageIdBase=(0,e.uuidv4)(),this._messageIdSeq=0;const n=e=>{var t;s&&"init"!==e&&("reading"===e?(this.state="awaitingMessage",this._messageIdSeq++,null===(t=this._awaitingMessageResolve)||void 0===t||t.call(this)):"sleeping"===e?(this.state="sleeping",this._messageIdSeq++):"slept"===e&&(this.state="running"))};this._interruptPromise=new Promise(((e,t)=>this._interruptRejector=t));try{return yield Promise.race([r(this.channel,t.proxy(n),this._messageIdBase,...i),this._interruptPromise])}finally{s=!1,this._reset()}}))}writeMessage(e){return s(this,void 0,void 0,(function*(){if("idle"===this.state||!this._messageIdBase)throw new Error("No active call to send a message to.");if("awaitingMessage"!==this.state){if(this._awaitingMessageResolve)throw new Error("Not waiting for message, and another write is already queued.");yield new Promise((e=>{this._awaitingMessageResolve=e})),delete this._awaitingMessageResolve}yield this._writeMessage({message:e})}))}terminate(){var e;null===(e=this._interruptRejector)||void 0===e||e.call(this,new r("Worker terminated")),this.workerProxy[t.releaseProxy](),this.worker.terminate(),delete this.workerProxy,delete this.worker}_writeMessage(t){return s(this,void 0,void 0,(function*(){this.state="running";const s=l(this._messageIdBase,this._messageIdSeq);yield(0,e.writeMessage)(this.channel,t,s)}))}_start(){this._reset(),this.worker=this.workerCreator(),this.workerProxy=t.wrap(this.worker)}_reset(){this.state="idle",delete this._interruptPromise,delete this._interruptRejector,delete this._awaitingMessageResolve,delete this._messageIdBase}}function h(t){return function(i,n,a,...h){return s(this,void 0,void 0,(function*(){yield n("init");let s=0;function u(t,h){if(!i)throw new o;n(t);const u=l(a,++s),d=(0,e.readMessage)(i,u,h);if(d){const{message:e,interrupted:t}=d;if(t)throw new r;return e}"sleeping"===t&&n("slept")}return t({channel:i,readMessage:()=>u("reading"),syncSleep(e){e>0&&u("sleeping",{timeout:e})}},...h)}))}}function l(e,t){return`${e}-${t}`}})(),n})()}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Papyros/./node_modules/comsync/dist/index.js?')},"./node_modules/sync-message/dist/index.js":module=>{eval('!function(e,t){ true?module.exports=t():0}(self,(function(){return(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{isServiceWorkerRequest:()=>s,serviceWorkerFetchListener:()=>i,asyncSleep:()=>u,ServiceWorkerError:()=>c,writeMessageAtomics:()=>a,writeMessageServiceWorker:()=>f,writeMessage:()=>d,makeChannel:()=>l,makeAtomicsChannel:()=>m,makeServiceWorkerChannel:()=>y,readMessage:()=>h,syncSleep:()=>g,uuidv4:()=>w});var r=function(e,t,r,n){return new(r||(r=Promise))((function(o,s){function i(e){try{c(n.next(e))}catch(e){s(e)}}function u(e){try{c(n.throw(e))}catch(e){s(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(i,u)}c((n=n.apply(e,t||[])).next())}))};const n="__SyncMessageServiceWorkerInput__",o="__sync-message-v2__";function s(e){return"string"!=typeof e&&(e=e.request.url),e.includes(n)}function i(){const e={},t={};return n=>{const{url:i}=n.request;return!!s(i)&&(n.respondWith(function(){return r(this,void 0,void 0,(function*(){function r(e){const t={message:e,version:o};return new Response(JSON.stringify(t),{status:200})}if(i.endsWith("/read")){const{messageId:o,timeout:s}=yield n.request.json();if(o in e){const t=e[o];return delete e[o],r(t)}return yield new Promise((e=>{t[o]=e,setTimeout((function(){delete t[o],e(new Response("",{status:408}))}),s)}))}if(i.endsWith("/write")){const{message:o,messageId:s}=yield n.request.json(),i=t[s];return i?(i(r(o)),delete t[s]):e[s]=o,r({early:!i})}if(i.endsWith("/version"))return new Response(o,{status:200})}))}()),!0)}}function u(e){return new Promise((t=>setTimeout(t,e)))}class c extends Error{constructor(e,t){super(`Received status ${t} from ${e}. Ensure the service worker is registered and active.`),this.url=e,this.status=t,this.type="ServiceWorkerError",Object.setPrototypeOf(this,c.prototype)}}function a(e,t){const r=(new TextEncoder).encode(JSON.stringify(t)),{data:n,meta:o}=e;if(r.length>n.length)throw new Error("Message is too big, increase bufferSize when making channel.");n.set(r,0),Atomics.store(o,0,r.length),Atomics.store(o,1,1),Atomics.notify(o,1)}function f(e,t,n){return r(this,void 0,void 0,(function*(){yield navigator.serviceWorker.ready;const r=e.baseUrl+"/write",s=Date.now();for(;;){const i={message:t,messageId:n},a=yield fetch(r,{method:"POST",body:JSON.stringify(i)});if(200===a.status&&(yield a.json()).version===o)return;if(!(Date.now()-s<e.timeout))throw new c(r,a.status);yield u(100)}}))}function d(e,t,n){return r(this,void 0,void 0,(function*(){"atomics"===e.type?a(e,t):yield f(e,t,n)}))}function l(e={}){return"undefined"!=typeof SharedArrayBuffer?m(e.atomics):"serviceWorker"in navigator?y(e.serviceWorker):null}function m({bufferSize:e}={}){return{type:"atomics",data:new Uint8Array(new SharedArrayBuffer(e||131072)),meta:new Int32Array(new SharedArrayBuffer(2*Int32Array.BYTES_PER_ELEMENT))}}function y(e={}){return{type:"serviceWorker",baseUrl:(e.scope||"/")+n,timeout:e.timeout||5e3}}function p(e,t){return e>0?+e:t}function h(e,t,{checkInterrupt:r,checkTimeout:n,timeout:s}={}){const i=performance.now();n=p(n,r?100:5e3);const u=p(s,Number.POSITIVE_INFINITY);let a;if("atomics"===e.type){const{data:t,meta:r}=e;a=()=>{if("timed-out"===Atomics.wait(r,1,0,n))return null;{const e=Atomics.exchange(r,0,0),n=t.slice(0,e);Atomics.store(r,1,0);const o=(new TextDecoder).decode(n);return JSON.parse(o)}}}else a=()=>{const r=new XMLHttpRequest,s=e.baseUrl+"/read";r.open("POST",s,!1);const u={messageId:t,timeout:n};r.send(JSON.stringify(u));const{status:a}=r;if(408===a)return null;if(200===a){const e=JSON.parse(r.responseText);return e.version!==o?null:e.message}if(performance.now()-i<e.timeout)return null;throw new c(s,a)};for(;;){const e=u-(performance.now()-i);if(e<=0)return null;n=Math.min(n,e);const t=a();if(null!==t)return t;if(null==r?void 0:r())return null}}function g(e,t){if(e=p(e,0))if("undefined"!=typeof SharedArrayBuffer){const t=new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));t[0]=0,Atomics.wait(t,0,0,e)}else h(t,`sleep ${e} ${w()}`,{timeout:e})}let w;return w="randomUUID"in crypto?function(){return crypto.randomUUID()}:function(){return"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(e=>{const t=Number(e);return(t^crypto.getRandomValues(new Uint8Array(1))[0]&15>>t/4).toString(16)}))},t})()}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Papyros/./node_modules/sync-message/dist/index.js?')},"./node_modules/comlink/dist/esm/comlink.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   expose: () => (/* binding */ expose),\n/* harmony export */   finalizer: () => (/* binding */ finalizer),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   proxyMarker: () => (/* binding */ proxyMarker),\n/* harmony export */   releaseProxy: () => (/* binding */ releaseProxy),\n/* harmony export */   transfer: () => (/* binding */ transfer),\n/* harmony export */   transferHandlers: () => (/* binding */ transferHandlers),\n/* harmony export */   windowEndpoint: () => (/* binding */ windowEndpoint),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol("Comlink.proxy");\nconst createEndpoint = Symbol("Comlink.endpoint");\nconst releaseProxy = Symbol("Comlink.releaseProxy");\nconst finalizer = Symbol("Comlink.finalizer");\nconst throwMarker = Symbol("Comlink.thrown");\nconst isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    ["proxy", proxyTransferHandler],\n    ["throw", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === "*") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = ["*"]) {\n    ep.addEventListener("message", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin \'${ev.origin}\' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case "GET" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case "SET" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case "APPLY" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case "CONSTRUCT" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case "ENDPOINT" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case "RELEASE" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === "RELEASE" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener("message", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === "function") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError("Unserializable return value"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === "MessagePort";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error("Proxy has been released and is not useable");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: "RELEASE" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = "FinalizationRegistry" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === "then") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: "GET" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: "SET" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: "ENDPOINT" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === "bind") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: "APPLY" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: "CONSTRUCT" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = "*") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: "HANDLER" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: "RAW" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case "HANDLER" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case "RAW" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener("message", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener("message", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join("-");\n}\n\n\n//# sourceMappingURL=comlink.mjs.map\n\n\n//# sourceURL=webpack://Papyros/./node_modules/comlink/dist/esm/comlink.mjs?')}}]);